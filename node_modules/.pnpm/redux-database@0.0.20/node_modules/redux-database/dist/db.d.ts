import { Row, RowIdentififying } from './util';
import { Table, DataTable, ContextChanges } from './table';
import { SettingsUpdateAction, TransactionAction, CommitContextAction, DBDispatch, RevertContextAction, TruncateAction, ResetAction } from './actions';
import { Query } from './query';
export interface Data {
    [key: string]: DataTable<Row>;
}
export interface StateDefining {
    settings: {
        [key: string]: unknown;
    };
    data: Data;
}
export interface ContextState {
    _context?: {
        [context: string]: {
            [table: string]: ContextChanges<Row>;
        };
    };
}
export declare type RowKeyOf<T extends StateDefining> = Extract<keyof T['data'], string>;
export declare type RowType<State extends StateDefining, Key extends RowKeyOf<State>> = State['data'][Key]['byId']['someKey'];
export declare type SettingsKey<T extends StateDefining> = Extract<keyof T['settings'], string>;
export declare type SettingsType<State extends StateDefining, Key extends SettingsKey<State>> = State['settings'][Key];
/**
 * `DB` is a snapshot of your current database state. It helps you reading data via [[`get`]], [[`table`]] and [[`query`]].
 *
 * ```ts
 * const db = new DB(state);
 *
 * db.get('enableAwesomeThing'); // true
 *
 * const things = db.table('things'); // if things is not defined, you would get an error here
 * things.all; // returns Thing[]
 * things.find('12'); // find by id
 * things.where({ name: 'tool' }); // simple equality based where queries
 * things.where(thing => thing.name.length == 4); // function based where queries
 * ```
 *
 * @typeParam State The state type of your database schema.
 *
 */
export declare class DB<State extends StateDefining> {
    private state;
    private currentContext?;
    /**
     * Create a snapshot from the given state. Can either be used in conjunction with redux or implicitly
     * by calling `mutableDB.snapshot`.
     */
    constructor(state: State, options?: {
        context?: string;
    });
    /**
     * Get the value from the key-value store.
     *
     * @param name A key of your key-value schema
     * @returns the value of the supplied key, `undefined` if no value is set yet
     * @category Key-Value Storage
     */
    get<K extends SettingsKey<State>>(name: K): SettingsType<State, K>;
    /**
     * Set a value in your key-value storage. This action does not mutate your state but returns an action
     * to be dispatched.
     *
     * @param name The key to update.
     * @param value The value to set for this key.
     * @returns {SettingsUpdateAction} Send this value to your dispatch function.
     * @category Key-Value Storage
     */
    set<K extends SettingsKey<State>, U extends SettingsType<State, K>>(name: K, value: U): SettingsUpdateAction;
    /**
     * Retrieve an immutable table by name. If you plan to compose a complex query, use [[`query`]] instead.
     *
     * ```ts
     * const things = db.table('things');
     * things.first
     * ```
     *
     * @param {K} type The name of the table to retrieve
     * @returns {Table<RowType<State, K>>} An immutable [[`Table`]] instance.
     * @category Table Storage
     */
    table<K extends RowKeyOf<State>>(type: K): Table<RowType<State, K>>;
    /**
     * Start a composable query. Queries allow chaining together different queries, joins and transformations.
     *
     * ```ts
     * const things = db.query('things').where({name: 'tool'}).embed('user', 'users', 'userId).order({name: 'desc'}).all;
     * ```
     *
     * @param {Key} type Name of the table to start the query on.
     * @returns {Query<State, Key, RowType<State, Key>>}
     * @category Table Storage
     */
    query<Key extends RowKeyOf<State>>(type: Key): Query<State, Key, RowType<State, Key>>;
    /**
     * Access a named context.
     *
     * ```ts
     * const draftDB = db.context('draft');
     * store.dispatch(draftDB.table('things').update('1', { name: 'Updated Thing' }));
     * // retrieve your state again from the store
     * db.table('things').first.name; // this is still 'First Thing'
     * draftDB.table('things').first.name; // this is updated to 'Updated Thing'
     * ```
     *
     * @param {string} context
     * @returns {DB<State>}
     * @category Context
     */
    context(context: string): DB<State>;
    /**
     * Start a transaction to group updates. This is mostly used to prevent rerenders if you're planning
     * to update multiple values and tables.
     *
     * ```ts
     * store.dispatch(
     *   db.transaction(dispatch => {
     *     dispatch(things.insert({ name: 'First Thing' }));
     *     dispatch(things.insert({ name: 'Second Thing' }));
     *   })
     * );
     * ```
     *
     * @param {(dispatch: DBDispatch) => void} execute Your execution function
     * @returns {TransactionAction} The action that you should send to your reducer.
     * @category Transactions
     */
    transaction(execute: (dispatch: DBDispatch) => void): TransactionAction;
    /**
     * Commit changes in a context to its parent. You can either commit individual ids, full tables
     * or the whole context.
     *
     * @param {K} [table] required if row-ids are given
     * @param {RowIdentififying} [ids]
     * @returns {CommitContextAction}
     * @category Context
     */
    commit<K extends RowKeyOf<State>>(table?: K, ids?: RowIdentififying): CommitContextAction;
    /**
     * Revert changes in a context. You can either revert individual ids, full tables
     * or the whole context.
     *
     * @param {K} [table] required if ids are given
     * @param {RowIdentififying} [ids]
     * @returns {RevertContextAction}
     * @category Context
     */
    revert<K extends RowKeyOf<State>>(table?: K, ids?: RowIdentififying): RevertContextAction;
    /**
     * Truncates all tables. After this action, all tables are empty. This will not change settings.
     * If you would like to reset settings instead, use [[reset]].
     *
     * @category Reset
     */
    truncate(): TruncateAction;
    /**
     * Resets the given type back to the initial state. If you want to have empty tables, use
     * [[truncate]] instead.
     *
     * - `all`: Reset settings and tables back to initial state.
     * - `tables`: Reset tables, but keeps current settings.
     * - `settings`: Reset settings, but keeps all tables.
     *
     * @category Reset
     */
    reset(type?: 'all' | 'tables' | 'settings'): ResetAction;
    private changeSetsOfContext;
}
