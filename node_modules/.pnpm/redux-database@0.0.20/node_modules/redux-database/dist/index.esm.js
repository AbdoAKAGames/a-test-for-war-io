var emptyTable = Object.freeze({
  byId: {},
  ids: []
});
function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }

  return [s4() + s4(), s4(), s4(), s4(), s4() + s4() + s4()].join('-');
}
function byId(records) {
  var map = {};
  records.forEach(e => map[e.id] = e);
  return map;
}
function pick(obj) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var ret = {};

  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  keys.forEach(key => {
    ret[key] = obj[key];
  });
  return ret;
}
function except(object, keys) {
  var newObject = {};
  var key;

  for (key in object) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (!keys.includes(key)) {
      newObject[key] = object[key];
    }
  }

  return newObject;
}
function extractIds(object) {
  if (object === undefined) {
    throw new Error('Trying to insert/update record which was not saved before');
  }

  var test;

  if (!(object instanceof Array)) {
    test = [object];
  } else {
    test = object;
  }

  return test.map(e => e['id'] || e);
}
function applyId(record) {
  var copy = Object.assign({}, record);

  if (!copy.id) {
    copy.id = guid();
  }

  return copy;
}
function extractParentContext(context) {
  var index = context.lastIndexOf('.');

  if (index > 1) {
    return context.substr(0, index);
  }

  return;
}
function flatten(items) {
  return items.reduce((array, item) => array.concat(item), []);
}
function compact(items) {
  return items.filter(e => e !== undefined);
}
function removeByValue(array, element) {
  var index = array.indexOf(element);

  if (index !== -1) {
    array.splice(index, 1);
  }
}
function formatResultToTableData(results) {
  var ids = [];
  var byId = {};

  for (var result of results) {
    ids.push(result.id);
    byId[result.id] = result;
  }

  return {
    ids,
    byId
  };
}
function orderBy(elements, key) {
  var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'asc';
  return elements.concat().sort((a, b) => {
    if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {
      return 0;
    }

    var varA = a[key];
    var varB = b[key];
    var comparison = 0;

    if (varA > varB) {
      comparison = 1;
    } else if (varA < varB) {
      comparison = -1;
    }

    return order === 'desc' ? comparison * -1 : comparison;
  });
}
function order(elements, sortDescriptor) {
  if (typeof sortDescriptor === 'string') {
    elements = orderBy(elements, sortDescriptor);
  } else {
    Object.keys(sortDescriptor).forEach(key => {
      elements = orderBy(elements, key, sortDescriptor[key]);
    });
  }

  return elements;
}
function deepEqual(a, b) {
  // even though it seems counterintuitive, stringify is extremely fast and even faster than most js
  // implementations of deep equal.
  return JSON.stringify(a) === JSON.stringify(b);
}

class Table {
  constructor(data, key) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.data = data;
    this.key = key;
    this.context = options.context;
    this.contextChanges = options.contextChanges;
  }

  get name() {
    return this.key;
  }

  find(id) {
    if (!this.ids.includes(id)) {
      return;
    }

    var changes = this.contextChanges && this.contextChanges.map(e => e.byId[id]);
    var object = this.data.byId[id];
    return changes ? Object.assign({}, object, ...changes) : object;
  }

  get all() {
    return this.ids.map(id => this.find(id));
  }

  get first() {
    return this.find(this.ids[0]);
  }

  get last() {
    return this.find(this.ids[this.ids.length - 1]);
  }

  get length() {
    return this.ids.length;
  }

  where(query) {
    if (typeof query === 'function') {
      return this.all.filter(query);
    } else {
      return this.all.filter(e => {
        for (var key of Object.keys(query)) {
          if (e[key] !== query[key]) {
            return false;
          }
        }

        return true;
      });
    }
  }

  insert(records) {
    var newRecords = records instanceof Array ? records : [records];
    var insertedRecords = newRecords.map(e => applyId(e));
    return {
      type: 'INSERT_RECORD',
      payload: {
        key: this.key,
        context: this.context,
        ids: insertedRecords.map(e => e.id),
        data: insertedRecords
      }
    };
  }

  upsert(records) {
    var newRecords = records instanceof Array ? records : [records];
    var insertedRecords = newRecords.map(e => applyId(e));
    return {
      type: 'UPSERT_RECORD',
      payload: {
        key: this.key,
        context: this.context,
        ids: insertedRecords.map(e => e.id),
        data: insertedRecords
      }
    };
  }

  update(id, values) {
    return {
      type: 'UPDATE_RECORD',
      payload: {
        key: this.key,
        context: this.context,
        ids: extractIds(id),
        data: values
      }
    };
  }

  delete(id) {
    return {
      type: 'DELETE_RECORD',
      payload: {
        key: this.key,
        context: this.context,
        ids: extractIds(id)
      }
    };
  }

  truncate() {
    return {
      type: 'TRUNCATE',
      payload: {
        type: 'table',
        key: this.key
      }
    };
  }

  reset() {
    return {
      type: 'RESET',
      payload: {
        type: 'table',
        key: this.key
      }
    };
  }

  commit(ids) {
    if (!this.context) {
      throw new Error('Called commit on a root context.');
    }

    return {
      type: 'COMMIT_CONTEXT',
      payload: {
        context: this.context,
        table: this.key,
        ids: ids ? extractIds(ids) : undefined
      }
    };
  }

  revert(ids) {
    if (!this.context) {
      throw new Error('Called commit on a root context.');
    }

    return {
      type: 'REVERT_CONTEXT',
      payload: {
        context: this.context,
        table: this.key,
        ids: ids ? extractIds(ids) : undefined
      }
    };
  }

  get changes() {
    var changes = compact([...this.ids, ...this.deletedIds].map(id => this.changesFor(id)));
    return changes.filter(e => e.deleted || e.inserted || e.changes);
  }

  changesFor(id) {
    if (!this.data.ids.includes(id) && !this.newIds.includes(id)) {
      return;
    }

    var deleted = this.deletedIds.includes(id);
    var inserted = this.newIds.includes(id);
    var changeSets = (this.contextChanges || []).map(e => e.byId[id]).filter(Boolean);
    var changes = changeSets.length > 0 ? changeSets.reduce((obj, change) => Object.assign({}, obj, change), {}) : undefined;
    return {
      id,
      deleted,
      inserted,
      changes
    };
  }

  get ids() {
    var deletedIds = this.deletedIds;
    return this.data.ids.concat(this.newIds).filter(id => !deletedIds.includes(id));
  }

  get newIds() {
    return flatten((this.contextChanges || []).map(e => e.newIds));
  }

  get deletedIds() {
    return flatten((this.contextChanges || []).map(e => e.deletedIds));
  }

}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

class Query {
  constructor(db, table) {
    this.db = db;
    this.table = table;
  }

  get first() {
    return this.table.first;
  }

  get last() {
    return this.table.last;
  }

  find(id) {
    return this.table.find(id);
  }

  get all() {
    return this.table.all;
  }

  get length() {
    return this.table.ids.length;
  }

  select() {
    for (var _len = arguments.length, fields = new Array(_len), _key = 0; _key < _len; _key++) {
      fields[_key] = arguments[_key];
    }

    var results = this.all.map(object => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore
      return pick(object, 'id', ...fields);
    });
    return this.queryFromResults(results);
  }

  where(query) {
    var results = this.table.where(query);
    return this.queryFromResults(results);
  }

  limit(amount) {
    var results = this.all.slice(0, amount);
    return this.queryFromResults(results);
  }

  offset(amount) {
    var results = this.all.slice(amount);
    return this.queryFromResults(results);
  }

  orderBy(sortDescriptor) {
    var results = order(this.table.all, sortDescriptor);
    return this.queryFromResults(results);
  }

  embed(key, table, source) {
    var results = this.all.map(e => {
      var embed = e[source] ? this.db.table(table).find(e[source]) : undefined;
      return _objectSpread2(_objectSpread2({}, e), {}, {
        [key]: embed
      });
    }); // eslint-disable-next-line @typescript-eslint/no-explicit-any

    return this.queryFromResults(results);
  }

  embedMulti(key, table, source) {
    var results = this.all.map(e => {
      var ids = e[source] || [];
      var embed = compact(ids.map(id => this.db.table(table).find(id)));
      return _objectSpread2(_objectSpread2({}, e), {}, {
        [key]: embed
      });
    }); // eslint-disable-next-line @typescript-eslint/no-explicit-any

    return this.queryFromResults(results);
  }

  queryFromResults(results) {
    var table = new Table(formatResultToTableData(results), this.table.name);
    return new Query(this.db, table);
  }

}

/**
 * `DB` is a snapshot of your current database state. It helps you reading data via [[`get`]], [[`table`]] and [[`query`]].
 *
 * ```ts
 * const db = new DB(state);
 *
 * db.get('enableAwesomeThing'); // true
 *
 * const things = db.table('things'); // if things is not defined, you would get an error here
 * things.all; // returns Thing[]
 * things.find('12'); // find by id
 * things.where({ name: 'tool' }); // simple equality based where queries
 * things.where(thing => thing.name.length == 4); // function based where queries
 * ```
 *
 * @typeParam State The state type of your database schema.
 *
 */
class DB {
  /**
   * Create a snapshot from the given state. Can either be used in conjunction with redux or implicitly
   * by calling `mutableDB.snapshot`.
   */
  constructor(state) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.state = state;
    this.currentContext = options.context;
  }
  /**
   * Get the value from the key-value store.
   *
   * @param name A key of your key-value schema
   * @returns the value of the supplied key, `undefined` if no value is set yet
   * @category Key-Value Storage
   */


  get(name) {
    var anyState = this.state;

    if (this.currentContext && anyState._context && anyState._context[this.currentContext] && anyState._context[this.currentContext][name]) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return anyState._context[this.currentContext][name];
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any


    return this.state.settings[name];
  }
  /**
   * Set a value in your key-value storage. This action does not mutate your state but returns an action
   * to be dispatched.
   *
   * @param name The key to update.
   * @param value The value to set for this key.
   * @returns {SettingsUpdateAction} Send this value to your dispatch function.
   * @category Key-Value Storage
   */


  set(name, value) {
    return {
      type: 'SETTINGS_UPDATE',
      payload: {
        context: this.currentContext,
        key: name,
        setting: value
      }
    };
  }
  /**
   * Retrieve an immutable table by name. If you plan to compose a complex query, use [[`query`]] instead.
   *
   * ```ts
   * const things = db.table('things');
   * things.first
   * ```
   *
   * @param {K} type The name of the table to retrieve
   * @returns {Table<RowType<State, K>>} An immutable [[`Table`]] instance.
   * @category Table Storage
   */


  table(type) {
    var contextChanges = this.currentContext ? this.changeSetsOfContext(type, this.currentContext) : undefined;
    return new Table(this.state.data[type], type, {
      context: this.currentContext,
      contextChanges // eslint-disable-next-line @typescript-eslint/no-explicit-any

    });
  }
  /**
   * Start a composable query. Queries allow chaining together different queries, joins and transformations.
   *
   * ```ts
   * const things = db.query('things').where({name: 'tool'}).embed('user', 'users', 'userId).order({name: 'desc'}).all;
   * ```
   *
   * @param {Key} type Name of the table to start the query on.
   * @returns {Query<State, Key, RowType<State, Key>>}
   * @category Table Storage
   */


  query(type) {
    return new Query(this, this.table(type));
  }
  /**
   * Access a named context.
   *
   * ```ts
   * const draftDB = db.context('draft');
   * store.dispatch(draftDB.table('things').update('1', { name: 'Updated Thing' }));
   * // retrieve your state again from the store
   * db.table('things').first.name; // this is still 'First Thing'
   * draftDB.table('things').first.name; // this is updated to 'Updated Thing'
   * ```
   *
   * @param {string} context
   * @returns {DB<State>}
   * @category Context
   */


  context(context) {
    var {
      currentContext
    } = this;

    if (currentContext) {
      context = currentContext + '.' + context;
    }

    return new DB(this.state, {
      context
    });
  }
  /**
   * Start a transaction to group updates. This is mostly used to prevent rerenders if you're planning
   * to update multiple values and tables.
   *
   * ```ts
   * store.dispatch(
   *   db.transaction(dispatch => {
   *     dispatch(things.insert({ name: 'First Thing' }));
   *     dispatch(things.insert({ name: 'Second Thing' }));
   *   })
   * );
   * ```
   *
   * @param {(dispatch: DBDispatch) => void} execute Your execution function
   * @returns {TransactionAction} The action that you should send to your reducer.
   * @category Transactions
   */


  transaction(execute) {
    var actions = [];
    execute(action => actions.push(action));
    return {
      type: 'TRANSACTION',
      payload: {
        actions
      }
    };
  }
  /**
   * Commit changes in a context to its parent. You can either commit individual ids, full tables
   * or the whole context.
   *
   * @param {K} [table] required if row-ids are given
   * @param {RowIdentififying} [ids]
   * @returns {CommitContextAction}
   * @category Context
   */


  commit(table, ids) {
    var {
      currentContext
    } = this;

    if (!currentContext) {
      throw new Error('Called commit on a root context.');
    }

    return {
      type: 'COMMIT_CONTEXT',
      payload: {
        context: currentContext,
        table,
        ids: ids ? extractIds(ids) : undefined
      }
    };
  }
  /**
   * Revert changes in a context. You can either revert individual ids, full tables
   * or the whole context.
   *
   * @param {K} [table] required if ids are given
   * @param {RowIdentififying} [ids]
   * @returns {RevertContextAction}
   * @category Context
   */


  revert(table, ids) {
    var {
      currentContext
    } = this;

    if (!currentContext) {
      throw new Error('Called commit on a root context.');
    }

    return {
      type: 'REVERT_CONTEXT',
      payload: {
        context: currentContext,
        table,
        ids: ids ? extractIds(ids) : undefined
      }
    };
  }
  /**
   * Truncates all tables. After this action, all tables are empty. This will not change settings.
   * If you would like to reset settings instead, use [[reset]].
   *
   * @category Reset
   */


  truncate() {
    return {
      type: 'TRUNCATE',
      payload: {
        type: 'database'
      }
    };
  }
  /**
   * Resets the given type back to the initial state. If you want to have empty tables, use
   * [[truncate]] instead.
   *
   * - `all`: Reset settings and tables back to initial state.
   * - `tables`: Reset tables, but keeps current settings.
   * - `settings`: Reset settings, but keeps all tables.
   *
   * @category Reset
   */


  reset() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
    return {
      type: 'RESET',
      payload: {
        type: type
      }
    };
  }

  changeSetsOfContext(table, context) {
    var anyState = this.state;

    if (!context) {
      return [];
    }

    if (!anyState._context || !anyState._context[context] || !anyState._context[context][table]) {
      return this.changeSetsOfContext(table, extractParentContext(context));
    }

    return [...this.changeSetsOfContext(table, extractParentContext(context)), anyState._context[context][table]];
  }

}

class MutableTable {
  constructor(table, dispatch) {
    this.underlyingTable = table;
    this.dispatch = dispatch;
  }

  find(id) {
    return this.underlyingTable.find(id);
  }

  get all() {
    return this.underlyingTable.all;
  }

  get first() {
    return this.underlyingTable.first;
  }

  get last() {
    return this.underlyingTable.last;
  }

  get changes() {
    return this.underlyingTable.changes;
  }

  get ids() {
    return this.underlyingTable.ids;
  }

  get length() {
    return this.ids.length;
  }

  changesFor(id) {
    return this.underlyingTable.changesFor(id);
  }

  where(query) {
    return this.underlyingTable.where(query);
  }

  insert(records) {
    this.dispatch(this.underlyingTable.insert(records));
  }

  upsert(records) {
    this.dispatch(this.underlyingTable.upsert(records));
  }

  update(id, values) {
    this.dispatch(this.underlyingTable.update(id, values));
  }

  delete(id) {
    this.dispatch(this.underlyingTable.delete(id));
  }

  commit(ids) {
    this.dispatch(this.underlyingTable.commit(ids));
  }

  revert(ids) {
    this.dispatch(this.underlyingTable.revert(ids));
  }

  truncate() {
    this.dispatch(this.underlyingTable.truncate());
  }

}

function applyInContext(state, context, field, handler) {
  var contextContent = state._context || {};
  var changes = contextContent[context] && contextContent[context][field] || {
    byId: {},
    deletedIds: [],
    newIds: []
  };
  changes = handler(changes);
  var currentContext = contextContent[context] || {};
  return _objectSpread2(_objectSpread2({}, state), {}, {
    _context: _objectSpread2(_objectSpread2({}, contextContent), {}, {
      [context]: _objectSpread2(_objectSpread2({}, currentContext), {}, {
        [field]: _objectSpread2(_objectSpread2({}, currentContext[field]), changes)
      })
    })
  });
}

function reduce(state, action, options) {
  var {
    initialState
  } = options;

  switch (action.type) {
    case 'INSERT_RECORD':
      {
        var key = action.payload.key;
        var newIDs = action.payload.ids.filter(id => !state.data[key].ids.includes(id));

        if (action.payload.context) {
          state = applyInContext(state, action.payload.context, key, changes => {
            return _objectSpread2(_objectSpread2({}, changes), {}, {
              newIds: [...changes.newIds, ...newIDs],
              byId: _objectSpread2(_objectSpread2({}, changes.byId), byId(action.payload.data))
            });
          });
        } else {
          var dataSet = _objectSpread2(_objectSpread2({}, state.data[key]), {}, {
            byId: _objectSpread2(_objectSpread2({}, state.data[key].byId), byId(action.payload.data)),
            ids: [...state.data[key].ids, ...newIDs]
          });

          state = _objectSpread2(_objectSpread2({}, state), {}, {
            data: _objectSpread2(_objectSpread2({}, state.data), {}, {
              [key]: dataSet
            })
          });
        }

        break;
      }

    case 'UPSERT_RECORD':
      {
        var _key = action.payload.key;
        var currentIds = new Set(state.data[_key].ids);
        var context = action.payload.context;
        var newRecords = action.payload.data.filter(e => !currentIds.has(e.id));
        var existingRecords = action.payload.data.filter(e => currentIds.has(e.id));
        state = reduce(state, {
          type: 'INSERT_RECORD',
          payload: {
            ids: newRecords.map(e => e.id),
            key: _key,
            context,
            data: newRecords
          }
        }, options);

        for (var record of existingRecords) {
          state = reduce(state, {
            type: 'UPDATE_RECORD',
            payload: {
              ids: [record.id],
              key: _key,
              context,
              data: record
            }
          }, options);
        }

        break;
      }

    case 'DELETE_RECORD':
      {
        var _key2 = action.payload.key;
        var ids = action.payload.ids;

        if (action.payload.context) {
          state = applyInContext(state, action.payload.context, _key2, changes => {
            return _objectSpread2(_objectSpread2({}, changes), {}, {
              deletedIds: [...changes.deletedIds, ...ids]
            });
          });
        } else {
          var _dataSet = _objectSpread2(_objectSpread2({}, state.data[_key2]), {}, {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            byId: except(state.data[_key2].byId, ids),
            ids: state.data[_key2].ids.filter(e => !ids.includes(e))
          });

          state = _objectSpread2(_objectSpread2({}, state), {}, {
            data: _objectSpread2(_objectSpread2({}, state.data), {}, {
              [_key2]: _dataSet
            })
          });
        }

        break;
      }

    case 'UPDATE_RECORD':
      {
        var _key3 = action.payload.key;

        if (action.payload.context) {
          state = applyInContext(state, action.payload.context, _key3, changes => {
            var updates = {};
            action.payload.ids.forEach(e => updates[e] = _objectSpread2(_objectSpread2({}, changes.byId[e]), action.payload.data));
            return _objectSpread2(_objectSpread2({}, changes), {}, {
              byId: _objectSpread2(_objectSpread2({}, changes.byId), updates)
            });
          });
        } else {
          var updatedId = action.payload.data['id'];
          var updates = {};
          action.payload.ids.forEach(e => updates[updatedId || e] = _objectSpread2(_objectSpread2({}, state.data[_key3].byId[e]), action.payload.data));

          var _dataSet2 = _objectSpread2(_objectSpread2({}, state.data[_key3]), {}, {
            byId: _objectSpread2(_objectSpread2({}, state.data[_key3].byId), updates)
          });

          if (updatedId !== undefined) {
            action.payload.ids.forEach(id => {
              if (id === updatedId) {
                return;
              }

              delete _dataSet2.byId[id];
            });
            _dataSet2.ids = _dataSet2.ids.map(e => action.payload.ids.includes(e) ? updatedId : e);
          }

          state = _objectSpread2(_objectSpread2({}, state), {}, {
            data: _objectSpread2(_objectSpread2({}, state.data), {}, {
              [_key3]: _dataSet2
            })
          });
        }

        break;
      }

    case 'TRUNCATE':
      {
        switch (action.payload.type) {
          case 'table':
            state = _objectSpread2(_objectSpread2({}, state), {}, {
              data: _objectSpread2(_objectSpread2({}, state.data), {}, {
                [action.payload.key]: _objectSpread2({}, emptyTable)
              })
            });
            break;

          case 'database':
            {
              var tables = Object.keys(state.data);
              state = _objectSpread2(_objectSpread2({}, state), {}, {
                data: {}
              });

              for (var _table of tables) {
                state.data[_table] = _objectSpread2({}, emptyTable);
              }
            }
        }

        break;
      }

    case 'RESET':
      {
        switch (action.payload.type) {
          case 'all':
            state = initialState;
            break;

          case 'table':
            state = _objectSpread2(_objectSpread2({}, state), {}, {
              data: _objectSpread2(_objectSpread2({}, state.data), {}, {
                [action.payload.key]: _objectSpread2({}, initialState.data[action.payload.key])
              })
            });
            break;

          case 'tables':
            state = _objectSpread2(_objectSpread2({}, state), {}, {
              data: initialState.data
            });
            break;

          case 'settings':
            state = _objectSpread2(_objectSpread2({}, state), {}, {
              settings: initialState.settings
            });
            break;
        }

        break;
      }

    case 'SETTINGS_UPDATE':
      {
        var _key4 = action.payload.key;

        if (action.payload.context) {
          var contextState = state;

          var _context = contextState._context || {};

          var currentContext = _context[action.payload.context] || {};
          state = _objectSpread2(_objectSpread2({}, state), {}, {
            _context: _objectSpread2(_objectSpread2({}, _context), {}, {
              [action.payload.context]: currentContext
            })
          });
        } else {
          state = _objectSpread2(_objectSpread2({}, state), {}, {
            settings: _objectSpread2(_objectSpread2({}, state.settings), {}, {
              [_key4]: action.payload.setting
            })
          });
        }

        break;
      }

    case 'COMMIT_CONTEXT':
      {
        var _context2 = action.payload.context;
        var tableToMerge = action.payload.table;
        var idsToMerge = action.payload.ids;
        var _contextState = state;
        var revertedState = reduce(state, {
          type: 'REVERT_CONTEXT',
          payload: {
            context: _context2,
            table: tableToMerge,
            ids: idsToMerge
          }
        }, options);
        var parentContext = extractParentContext(_context2);
        var changes = _contextState._context && _contextState._context[_context2] || {};

        if (parentContext) {
          var parentContextChanges = _objectSpread2({}, _contextState._context[parentContext]);

          Object.keys(changes).forEach(table => {
            if (tableToMerge && tableToMerge !== table) {
              return;
            }

            var change = changes[table];

            if (!parentContextChanges[table]) {
              Object.assign(parentContextChanges, {
                [table]: {
                  byId: {},
                  newIds: [],
                  deletedIds: []
                }
              });
            }

            var parentChange = parentContextChanges[table];
            parentChange.newIds = [...parentChange.newIds, ...change.newIds.filter(e => !idsToMerge || idsToMerge.includes(e))];
            parentChange.deletedIds = [...parentChange.deletedIds, ...change.deletedIds];
            Object.keys(change.byId).forEach(id => {
              if (idsToMerge && !idsToMerge.includes(id)) {
                return;
              }

              parentChange.byId[id] = _objectSpread2(_objectSpread2({}, parentChange.byId[id]), change.byId[id]);
            });
          });
          state = _objectSpread2(_objectSpread2({}, state), {}, {
            _context: _objectSpread2(_objectSpread2({}, revertedState._context), {}, {
              [parentContext]: parentContextChanges
            })
          });
        } else {
          state = _objectSpread2(_objectSpread2({}, state), {}, {
            data: _objectSpread2({}, state.data),
            // create a new object so it's ok to modify it later
            _context: revertedState._context
          });
          Object.keys(changes).forEach(table => {
            if (tableToMerge && tableToMerge !== table) {
              return;
            }

            var change = changes[table];
            var data = state.data[table];
            state.data[table] = {
              ids: data.ids.concat(change.newIds.filter(id => !idsToMerge || idsToMerge.includes(id))).filter(id => !change.deletedIds.includes(id)),
              byId: _objectSpread2({}, data.byId)
            };
            Object.keys(change.byId).forEach(id => {
              if (idsToMerge && !idsToMerge.includes(id)) {
                return;
              }

              state.data[table].byId[id] = _objectSpread2(_objectSpread2({}, state.data[table].byId[id]), change.byId[id]);
            });
          });
        }

        break;
      }

    case 'REVERT_CONTEXT':
      {
        var _contextState2 = state;
        var _context3 = action.payload.context;

        var _changes = _contextState2._context && _contextState2._context[_context3] || {};

        var tableToRevert = action.payload.table;
        var idsToRevert = action.payload.ids;
        var contextUpdates;

        if (tableToRevert) {
          contextUpdates = _objectSpread2({}, _changes);

          if (idsToRevert) {
            var contextTableChange = contextUpdates[tableToRevert];
            var tableChanges = {};
            Object.keys(contextTableChange.byId).forEach(id => {
              if (idsToRevert.includes(id)) {
                return;
              }

              tableChanges[id] = contextTableChange.byId[id];
            });
            contextUpdates[tableToRevert] = {
              byId: tableChanges,
              deletedIds: contextTableChange.deletedIds.filter(id => !idsToRevert.includes(id)),
              newIds: contextTableChange.newIds.filter(id => !idsToRevert.includes(id))
            };
          } else {
            delete contextUpdates[tableToRevert];
          }
        }

        state = _objectSpread2(_objectSpread2({}, state), {}, {
          _context: _objectSpread2(_objectSpread2({}, _contextState2._context), {}, {
            [_context3]: contextUpdates
          })
        });
        break;
      }

    case 'TRANSACTION':
      {
        action.payload.actions.forEach(a => {
          state = reduce(state, a, options);
        });
        break;
      }
  }

  return state;
}
function reducer(initialState) {
  return (state, action) => {
    if (!state) {
      state = initialState;
    }

    return reduce(state, action, {
      initialState
    });
  };
}

class Subscription {
  constructor(db, query) {
    this.db = db;
    this._query = query;
    this.subscribers = [];
    this._current = query(db.snapshot);
    this.unsubscribe = db.subscribe(() => this.trigger());
  }

  get query() {
    return this._query;
  }

  set query(query) {
    // when assigning the same instance of query, skip notifications (this happens e.g. in React
    // when assining a query on each render)
    if (this._query !== query) {
      this._query = query;
      this.trigger();
    }
  }

  get current() {
    return this._current;
  }

  subscribe(callback) {
    this.subscribers.push(callback);
    callback(this._current);
    return () => {
      removeByValue(this.subscribers, callback);
    };
  }

  cancel() {
    this.unsubscribe();
    this.subscribers = [];
  }

  trigger() {
    var newValue = this._query(this.db.snapshot);

    if (!deepEqual(this.current, newValue)) {
      this._current = newValue;
      this.subscribers.forEach(e => e(newValue));
    }
  }

}

class MutableDB {
  constructor(state) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.state = state;
    this.currentContext = options.context;
    this.store = options.store;
    this.reducer = reducer(this.state);
    this.subscribers = [];
    this.cachedTables = {};

    if (options.store) {
      options.store.subscribe(() => {
        this.readState(this.store.getState());
      });
    }
  }

  get snapshot() {
    return new DB(this.state, {
      context: this.currentContext
    });
  }

  get(name) {
    return this.snapshot.get(name);
  }

  set(name, value) {
    this.dispatch(this.snapshot.set(name, value));
  }

  table(type) {
    if (this.cachedTables[type]) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return this.cachedTables[type];
    } else {
      this.cachedTables[type] = new MutableTable(this.snapshot.table(type), this.dispatch.bind(this) // eslint-disable-next-line @typescript-eslint/no-explicit-any
      );
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any


    return this.cachedTables[type];
  }

  query(type) {
    var db = this.snapshot;
    return new Query(db, db.table(type));
  }

  context(context) {
    return new MutableDB(this.state, {
      context,
      store: this.store
    });
  }

  transaction(execute) {
    this.dispatch(this.snapshot.transaction(dispatch => execute(this.snapshot, dispatch)));
  }

  commit(table, ids) {
    this.dispatch(this.snapshot.commit(table, ids));
  }

  revert(table, ids) {
    this.dispatch(this.snapshot.revert(table, ids));
  }

  truncate() {
    this.dispatch(this.snapshot.truncate());
  }

  reset() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
    this.dispatch(this.snapshot.reset(type));
  }

  subscribe(callback) {
    this.subscribers.push(callback);
    return () => {
      removeByValue(this.subscribers, callback);
    };
  }

  observe(query) {
    return new Subscription(this, query);
  }

  dispatch(action) {
    if (this.store) {
      this.store.dispatch(action);
    } else {
      this.readState(this.reducer(this.state, action));
    }

    this.subscribers.forEach(e => e(action));
  }

  readState(state) {
    this.state = state;
    Object.keys(this.cachedTables).forEach(type => {
      var table = this.cachedTables[type];

      if (!table) {
        return;
      }

      table.underlyingTable['data'] = state.data[type];
      table.underlyingTable['contextChanges'] = this.snapshot.table(type)['contextChanges'];
    });
  }

}

export { DB, MutableDB, Query, Subscription, emptyTable, guid, reducer };
