import { DataTable } from './table';
export declare type OptionalID = {
    id?: string;
};
export declare type InsertRecord<T extends Row> = {
    id?: string;
} & Omit<T, 'id'>;
export declare type RowInsertionList<T extends Row> = InsertRecord<T> | Array<InsertRecord<T>>;
export interface Row {
    id: string;
}
export declare type RowIdentififying = string | string[] | Row | Row[];
export declare const emptyTable: Readonly<{
    byId: {};
    ids: never[];
}>;
export declare function guid(): string;
export declare function byId(records: Row[]): {
    [id: string]: Row;
};
export declare function pick<T extends {}, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;
export declare function except<T extends {}, Key extends [...(keyof T)[]]>(object: T, keys: Key[]): {
    [K2 in Exclude<keyof T, Key[number]>]: T[K2];
};
export declare function extractIds(object: RowIdentififying): string[];
export declare function applyId<T>(record: OptionalID): T;
export declare function extractParentContext(context: string): string | undefined;
export declare function flatten<T>(items: T[][]): T[];
export declare function compact<T>(items: Array<T | undefined>): T[];
export declare function removeByValue<T>(array: Array<T>, element: T): void;
export declare function formatResultToTableData<RowType extends Row>(results: RowType[]): DataTable<RowType>;
export declare function orderBy<T extends {}, Key extends keyof T>(elements: T[], key: Key, order?: 'asc' | 'desc'): T[];
declare type SimpleSortDescriptor<T> = keyof T;
declare type DetailedSortDescriptor<T> = {
    [P in keyof T]?: 'asc' | 'desc';
};
export declare type SortDescriptor<T> = SimpleSortDescriptor<T> | DetailedSortDescriptor<T>;
export declare function order<T extends {}>(elements: T[], sortDescriptor: SortDescriptor<T>): T[];
export declare function deepEqual<T>(a: T, b: T): boolean;
export {};
