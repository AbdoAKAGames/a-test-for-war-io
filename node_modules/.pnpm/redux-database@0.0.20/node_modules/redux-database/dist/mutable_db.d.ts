import { MutableTable } from './mutable_table';
import type { DBDispatch, DBAction } from './actions';
import { DB, SettingsKey, SettingsType, RowKeyOf, RowType } from './db';
import type { StateDefining } from './db';
import { RowIdentififying } from './util';
import { Query } from './query';
import { Subscription } from './subscription';
interface Store<State extends StateDefining> {
    subscribe: (callback: () => void) => void;
    getState: () => State;
    dispatch: (action: DBAction) => void;
}
export declare class MutableDB<State extends StateDefining> {
    private state;
    private currentContext?;
    private reducer;
    private store?;
    private subscribers;
    private cachedTables;
    constructor(state: State, options?: {
        context?: string;
        store?: Store<State>;
    });
    get snapshot(): DB<State>;
    get<K extends SettingsKey<State>>(name: K): SettingsType<State, K>;
    set<K extends SettingsKey<State>, U extends SettingsType<State, K>>(name: K, value: U): void;
    table<K extends RowKeyOf<State>>(type: K): MutableTable<RowType<State, K>>;
    query<Key extends RowKeyOf<State>>(type: Key): Query<State, Key, RowType<State, Key>>;
    context(context: string): MutableDB<State>;
    transaction(execute: (db: DB<State>, dispatch: DBDispatch) => void): void;
    commit<K extends RowKeyOf<State>>(table?: K, ids?: RowIdentififying): void;
    revert<K extends RowKeyOf<State>>(table?: K, ids?: RowIdentififying): void;
    truncate(): void;
    reset(type?: 'all' | 'tables' | 'settings'): void;
    subscribe(callback: (action: DBAction) => void): () => void;
    observe<T>(query: (db: DB<State>) => T): Subscription<State, T>;
    private dispatch;
    private readState;
}
export {};
